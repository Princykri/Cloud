1. Write a shell script to back up a directory
	•	Create a script that takes a source directory and a backup directory as arguments.
	•	It should copy the contents of the source into the backup directory with the current date appended (e.g., backup-2025-06-19).

#!/bin/bash

if [ "$#" -ne 2 ]; then
     echo "Usage:$0 <source_directory> <backup_directory>"
     exit 1
fi

SOURCE_DIR="$1"
BACKUP_DIR="$2"
TODAY=$(date +%F)

DESTINATION="$BACKUP_DIR/BACKUP-$TODAY"
mkdir -p "$DESTINATION"

cp -r "$SOURCE_DIR"/* "$DESTINATION"

echo "backup completed successfully at : $DESTINATION"
~                                                                                                                       ~                                                            

2. Schedule the above backup script with a cron job
	•	Set up a cron job that runs the backup script daily at 2 AM.
	•	Add instructions or crontab -e entry in the script or a .cron file.

#!/bin/bash

if [ "$#" -ne 2 ]; then
     echo "Usage:$0 <source_directory> <backup_directory>"
     exit 1
fi

SOURCE_DIR="$1"
BACKUP_DIR="$2"
TODAY=$(date +%F)

DESTINATION="$BACKUP_DIR/BACKUP-$TODAY"
mkdir -p "$DESTINATION"

cp -r "$SOURCE_DIR"/* "$DESTINATION"

echo "backup completed successfully at : $DESTINATION"
~                                                            


3. Create a script to archive and compress log files
	•	The script should find all .log files older than 7 days in /var/logs, compress them into a .tar.gz file, and move it to /backup/logs/.
#!/bin/bash

LOG_DIR="/home/Princy/Questions/03/test-log"
BACKUP_DIR="/home/Princy/Questions/03/test-backup"
TODAY=$(date +%F)
ARCHIVE_NAME="logs-$TODAY.tar.gz"

#step2 : create backup dir if it doesn't exist

mkdir -p "$BACKUP_DIR"

#step3 ": find and archive .log files older than 7 days

find "$LOG_DIR" -type f -name "*.log" -mtime +7 -print0 | tar -czf "$BACKUP_DIR/$ARCHIVE_NAME" --null -T -
echo "Logs archived to: $BACKUP_DIR/$ARCHIVE_NAME"
~                                                     

 4 . . Write a script to monitor disk usage
	•	If disk usage exceeds 80%, send an alert message to a log file or mail (mock with echo "Alert").
	•	Use df -h and parse output with awk.

#!/bin/bash
THRESHOLD=80
LOG_FILE="/home/Princy/Questions/04/disk-alert.log"

df -h --output=pcent,target | tail -n +2 | while read output;do
   usage=$(echo $output | awk '{print $1}'| tr -d '%')
   mount_point=$(echo $output | awk '{print $2}')

if [ "$usage" -ge "$THRESHOLD" ]; then
   echo "ALERT: Disk usage on $mount_point is ${usage}% — exceeds ${THRESHOLD}%" >> "$LOG_FILE"
else
        echo "OK: Disk usage on $mount_point is ${usage}%" >> "$LOG_FILE"
fi

done

5. Write a script to check if a list of services are running
	•	Input: List of service names (e.g., nginx, mysql).
	•	Output: Print whether each service is active, inactive, or not found.
#!/bin/bash

services=("nginx" "mysql" "ssh" "docker")

for service in "${services[@]}"; do
    if systemctl list-units --type=service --all | grep -q "^${service}.service"; then
        status=$(systemctl is-active "$service")
        echo "$service: $status"
    else
        echo "$service: not found"
    fi
done


.6. Build a menu-driven shell script
	•	Display options:
	1.	Show disk usage
	2.	Show memory usage
	3.	Show running processes
	4.	Exit
	•	Use case statements and loop until the user selects Exit.


#!/bin/bash

while true
do
    echo "========================="
    echo "     System Monitor Menu"
    echo "========================="
    echo "1. Show Disk Usage"
    echo "2. Show Memory Usage"
    echo "3. Show Running Processes"
    echo "4. Exit"
    echo "-------------------------"
    read -p "Enter your choice [1-4]: " choice

    case $choice in
        1)
            echo ">>> Disk Usage:"
            df -h
            ;;
        2)
            echo ">>> Memory Usage:"
            free -h
            ;;
        3)
            echo ">>> Running Processes:"
            ps aux --sort=-%mem | head -n 10
            ;;
        4)
            echo "Exiting... Goodbye!"
            break
            ;;
        *)
            echo "Invalid choice. Please enter a number from 1 to 4."
            ;;
    esac

    echo ""
    read -p "Press Enter to continue..."
    clear
done

7. Create a script to remove temporary files safely
	•	Accept a directory path as an argument.
	•	List all files inside /tmp older than 3 days and prompt the user before deleting.
#!/bin/bash

# Check if directory is provided
if [ -z "$1" ]; then
    echo "Usage: $0 <directory-path>"
    exit 1
fi

dir="$1"

# Check if the given directory exists
if [ ! -d "$dir" ]; then
    echo "Directory not found: $dir"
    exit 1
fi

echo "Temporary files older than 3 days in $dir:"
find "$dir" -type f -mtime +3

read -p "Do you want to delete these files? [y/N]: " confirm

if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
    find "$dir" -type f -mtime +3 -exec rm -v {} \;
    echo "Old files deleted."
else
    echo "Deletion cancelled."
fi

8. Write a function inside a script to validate an email address
	•	Take an email string as input.
	•	Check if it follows a valid format using regex.
	•	Print “Valid” or “Invalid”.
#!/bin/bash

validate_email() {
    local email="$1"
    if [[ "$email" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
        echo "Valid"
    else
        echo "Invalid"
    fi
}

read -p "Enter an email address: " input_email
validate_email "$input_email"

9. Write a script to compare two directories
	•	Print all the files that are only in one directory but not the other.
	•	Use diff, comm, or rsync in dry-run mode.
